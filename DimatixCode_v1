import numpy as np
import cv2
from operator import itemgetter

# Create a VideoCapture object
cap = cv2.VideoCapture('5khz_20V_CT60_MV3.avi')

# Check if camera opened successfully
if (cap.isOpened() == False):
    print("Unable to read camera feed")

# Default resolutions of the frame are obtained.The default resolutions are system dependent.
# Convert the resolutions from float to integer.
frame_width = int(cap.get(3))
frame_height = int(cap.get(4))

# Define the codec and create VideoWriter object.The output is stored in 'outpy.avi' file.
fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter("outpy_Apr30_No_value.avi", fourcc, 15.0, (frame_width, frame_height))
# out = cv2.VideoWriter('outpy1.avi', cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), 15, (frame_width, frame_height))

# Reading background image
while cap.isOpened() == True:
    ret, frame = cap.read()
    if ret == True:
        cv2.imwrite("frame##.jpg", frame)
        cv2.imread("frame##.jpg", -1)
        cv2.imshow("frame", cv2.imread("frame##.jpg", -1))

        if cv2.waitKey(0) & 0xFF == ord('n'):
            frame2 = cv2.imread("frame##.jpg", -1)
            # print(frame2.shape)
            break


frame_no = 1
while cap.isOpened() == True:
    ret, frame1 = cap.read()

    # if frame is read correctly ret is True

    if ret:
        print("frame ", frame_no)
        # Getting foreground for each selected image
        diff = cv2.absdiff(frame2, frame1)

        # Converting foreground to hsv to have color range for extracting contours
        hsv = cv2.cvtColor(diff, cv2.COLOR_BGR2HSV)

        # Lower and upper range of RGB
        lower_white = np.array([0, 0, 36])
        upper_white = np.array([0, 0, 255])

        # masking hsv image
        mask = cv2.inRange(hsv, lower_white, upper_white)

        # Extracting out contours from the masked image
        contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

        font = cv2.FONT_HERSHEY_SIMPLEX

        i = 1

        # Selecting needed contours based on a set value of area
        C = []
        #Width = []
        #Height = []
        Droplet_Details = []
        for c in contours:
            areas = cv2.contourArea(c)

            if areas > 10:

                x, y, w, h = cv2.boundingRect(c)
                cx = x + w / 2
                cy = y + h / 2


                if y < 0.4 * diff.shape[0]:
                    # Aggregating all the coordinates of cx's and cy's
                    C.append((cx, cy))
                    # print(i)
                    # print(areas)
                    # print(c)

                    ## For writing values on the frame ###
                    cv2.rectangle(frame1, (x, y), (x + w, y + int(0.5*h)), (255, 0, 0), 1)
                    cv2.putText(frame1, "w: {:.2f}".format(w), (x, y - 50), font, 0.3, (0, 0, 255), 1)
                    cv2.putText(frame1, "h: {:.2f}".format(h), (x, y - 30), font, 0.3, (255, 255, 255), 1)
                    cv2.putText(frame1, "AR: {:.2f}".format(w / h), (x, y - 10), font, 0.3, (0, 255, 255), 1)

                    #Width.append(w)
                    #Height.append(h)
                    Droplet_Details.append(((w,h,x,y)))
        #print("Width: ", Width)
        #print("Height: ", Height)
        #print("Details: ", Droplet_Details)

        data_sorted = sorted(Droplet_Details, key=itemgetter(2))
        #print("data_sorted", data_sorted)

        No_of_droplets = []
        for i in data_sorted:
            No_of_droplets.append(round(i[2] / 112 + 1))
        #print("No_of_droplets: ", No_of_droplets)

        unique_droplet = [1, 2, 3, 4, 5, 6, 7]
        #print("unique_droplet: ", unique_droplet)

        freq = []
        for i in unique_droplet:
            j = 0
            k = 0
            while j < len(No_of_droplets):
                if i == No_of_droplets[j]:
                    k += 1
                else:
                    k
                j += 1
            freq.append(k)
        #print("freq: ", freq)

        #########################################################################
        ######### Display of final results on PyCharm console ###################
        #########################################################################
        # Number of nozzles in view
        if len(data_sorted) == 0:
            print("There are", [round(frame_width / 112) + 1], "nozzles in the view")
        elif len(data_sorted) == 1:
            print("There are", [1], "nozzles in the view")
        else:
            print("There are", [round((data_sorted[-1][2] - data_sorted[0][2]) / 112) + 1], "nozzles in the view")

        print("\n")

        i = 0
        k = 0
        while i < len(freq):
            if freq[i] == 0:
                print("Nozzle #", i + 1, "has [", freq[i], "] droplets")
                cv2.putText(frame1, "{}-{}".format(unique_droplet[i], freq[i]),
                            (int(6 + 112 * i), int(0.4 * frame_height)), font, 0.3, (255, 255, 0), 1)

            else:
                q = 0
                X = []
                while q < freq[i]:
                    print("Nozzle #", i + 1, "has [", freq[i], "] droplets")

                    print("Droplet #", q + 1, "has a size of [", data_sorted[k+q][0] * data_sorted[k+q][1],
                          "] a length of [", data_sorted[k+q][1], "], a width of [", data_sorted[k+q][0],
                          "], an AR ratio of [{:.2f}".format(data_sorted[k+q][0] / data_sorted[k+q][1]),
                          "], a velocity of [velocity].")
                    X.append(data_sorted[k+q])
                    q += 1


                X_sorted = sorted(X, key=itemgetter(3))
                print("X_sorted", X_sorted)
                w = 0
                while w < freq[i]:
                    cv2.putText(frame1, "{}-{}".format(unique_droplet[i], w+1),
                            (int(X_sorted[w][2]), int(X_sorted[w][3])), font, 0.3, (255, 255, 0), 1)
                    w += 1

                k = k + w

            i += 1
            print("\n")

        print("========================================================================================================")

        cv2.imshow("Display", frame1)
        out.write(frame1)

    frame_no += 1

    if not ret:
        print("Can't receive frame (stream end?). Exiting ...")
        break

    if cv2.waitKey(100) == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

